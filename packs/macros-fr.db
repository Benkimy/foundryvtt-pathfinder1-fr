{"name": "\u00c9mettre de la lumi\u00e8re", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer/d\u00e9sactiver de la lumi\u00e8re sur un token\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst porteeCourte = 3;\nconst porteeLongue = 2 * porteeCourte;\n\n///// SCRIPT\nconst tokens = canvas.tokens.controlled.filter( t => t.actor && t.actor.hasPerm(game.user, \"OWNER\") )\n\nif( tokens.length == 0 ) { ui.notifications.error(\"Veuillez choisir un token sur la sc\u00e8ne!\"); }\nelse {\n  tokens.forEach( t => {\n    const radius1 = t.brightLightRadius > 0 || t.dimLightRadius > 0 ? 0 : porteeCourte\n    const radius2 = t.brightLightRadius > 0 || t.dimLightRadius > 0 ? 0 : porteeLongue\n    const hasLight = t.brightLightRadius > 0 || t.dimLightRadius > 0\n    t.update({brightLight: radius1, dimLight: radius2});\n    MacroMarker.toggle(this);\n  })\n}\n\n", "img": "systems/pf1/icons/items/inventory/lantern.jpg", "actorIds": [], "_id": "9ePEn6JQj3f7cB3T", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/items/inventory/lantern.jpg", "tooltip": "Retirer la lumi\u00e8re", "colour": "#edc412", "trigger": "\nconst tokens = canvas.tokens.controlled.filter( t => t.actor && t.actor.hasPerm(game.user, \"OWNER\") )\nreturn tokens.length > 0 && (tokens[0].brightLightRadius > 0 || tokens[0].dimLightRadius > 0)\n"}}}}
{"name": "Combattre sur la d\u00e9fensive", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer ou de d\u00e9sactiver la d\u00e9fense totale sur un personnage\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst BUFFNAME = \"Combattre sur la d\u00e9fensive\"\n\n///// SCRIPT\nasync function macroToggleTotalDefense() {\n\n  // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n  const actors = MacrosPF1.getActors()\n    \n  // V\u00e9rifier que l'acteur existe\n  if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n  const hero = actors[0];\n\n  let buff = hero.items.find( i => i.type === \"buff\" && i.name === BUFFNAME )\n  if( !buff ) {\n    buff = {\n      \"name\": BUFFNAME,\n      \"type\": \"buff\",\n      \"data\": {\n        \"description\": {\n          \"value\": \"Un personnage peut choisir de combattre sur la d\u00e9fensive lorsqu'il attaque. Dans ce cas, il subit un malus de -4 sur toutes ses attaques du round mais b\u00e9n\u00e9ficie alors d\u2019un bonus d\u2019esquive de +2 \u00e0 la CA jusqu'au d\u00e9but de son prochain tour.\",\n        },\n        \"changes\": [\n          {\n            \"formula\": \"-4\",\n            \"operator\": \"add\",\n            \"target\": \"attack\",\n            \"subTarget\": \"attack\",\n            \"modifier\": \"penalty\",\n            \"priority\": 0,\n            \"value\": 0\n          },\n          {\n            \"formula\": \"2\",\n            \"operator\": \"add\",\n            \"target\": \"ac\",\n            \"subTarget\": \"ac\",\n            \"modifier\": \"dodge\",\n            \"priority\": 0,\n            \"value\": 0\n          }\n        ],\n        \"contextNotes\": [\n          { \n            \"text\" : \"Sur la d\u00e9fensive\",\n            \"target\" : \"attacks\",\n            \"subTarget\" : \"attack\"\n          }\n        ],\n        \"buffType\": \"temp\",\n        \"active\": false,\n      },\n      \"img\": \"systems/pf1/icons/feats/improved-shield-bash.jpg\"\n    }\n\n    const created = await hero.createEmbeddedEntity(\"OwnedItem\", buff);\n    buff = hero.items.find( i => i.type === \"buff\" && i.name === BUFFNAME )\n  }\n\n  if( !buff ) { return ui.notifications.error(\"Modification non-disponible. Quelquechose ne fonctionne pas comme pr\u00e9vu.\") }\n  let active = getProperty(buff.data, \"data.active\");\n  if (active == null) active = false;\n  buff.update({ \"data.active\": !active });\n  if( !active ) { buff.roll(); }\n}\n\nmacroToggleTotalDefense();\n\n", "img": "systems/pf1/icons/feats/improved-shield-bash.jpg", "actorIds": [], "_id": "1IqmhS75L8bVcNqp", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/improved-shield-bash.jpg", "tooltip": "Combattre normalement", "colour": "#bba8a8", "trigger": "\nconst actors = MacrosPF1.getActors()\nif( actors.length > 0 ) {\n  const hero = actors[0];\n  const buff = hero.items.find( i => i.type === \"buff\" && i.name === \"Combattre sur la d\u00e9fensive\" )\n  return buff && getProperty(buff.data, \"data.active\")\n} \nreturn false\n"}}}}
{"name": "Activer D\u00e9fense Totale", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer ou de d\u00e9sactiver la d\u00e9fense totale sur un personnage\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst BUFFNAME = \"D\u00e9fense totale\"\n\n///// SCRIPT\nasync function macroToggleTotalDefense() {\n\n  // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n  const actors = MacrosPF1.getActors()\n    \n  // V\u00e9rifier que l'acteur existe\n  if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n  const hero = actors[0];\n\n  let buff = hero.items.find( i => i.type === \"buff\" && i.name === BUFFNAME )\n  if( !buff ) {\n    buff = {\n      \"name\": BUFFNAME,\n      \"type\": \"buff\",\n      \"data\": {\n        \"description\": {\n          \"value\": \"Un personnage peut consacrer une action simple \u00e0 sa d\u00e9fense, ce qui lui conf\u00e8re un bonus d'esquive de +4 \u00e0 la CA pendant 1 round. Sa CA s\u2019am\u00e9liore d\u00e8s le d\u00e9but de son action. Le personnage ne peut pas cumuler une d\u00e9fense totale avec un combat sur la d\u00e9fensive ou avec le don Expertise du combat. Un personnage en d\u00e9fense totale ne peut pas faire d\u2019attaques d\u2019opportunit\u00e9.\",\n        },\n        \"changes\": [\n          {\n            \"formula\": \"4\",\n            \"operator\": \"add\",\n            \"target\": \"ac\",\n            \"subTarget\": \"ac\",\n            \"modifier\": \"dodge\",\n            \"priority\": 0,\n            \"value\": 0\n          }\n        ],\n        \"buffType\": \"temp\",\n        \"active\": false,\n      },\n      \"img\": \"systems/pf1/icons/feats/shield-slam.jpg\"\n    }\n\n    const created = await hero.createEmbeddedEntity(\"OwnedItem\", buff);\n    buff = hero.items.find( i => i.type === \"buff\" && i.name === BUFFNAME )\n  }\n\n  if( !buff ) { return ui.notifications.error(\"Modification non-disponible. Quelquechose ne fonctionne pas comme pr\u00e9vu.\") }\n  let active = getProperty(buff.data, \"data.active\");\n  if (active == null) active = false;\n  buff.update({ \"data.active\": !active });\n  if( !active ) { buff.roll(); }\n}\n\nmacroToggleTotalDefense();\n\n", "img": "systems/pf1/icons/feats/shield-slam.jpg", "actorIds": [], "_id": "Tta2l2WwXVnBObxA", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/shield-slam.jpg", "tooltip": "D\u00e9sactiver D\u00e9fense Totale", "colour": "#bba8a8", "trigger": "\nconst actors = MacrosPF1.getActors()\nif( actors.length > 0 ) {\n  const hero = actors[0];\n  const buff = hero.items.find( i => i.type === \"buff\" && i.name === \"D\u00e9fense totale\" )\n  return buff && getProperty(buff.data, \"data.active\")\n} \nreturn false\n"}}}}
{"name": "Mettre \u00e0 jour les aptitudes", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro ajoute les aptitudes sur un PJ (bas\u00e9 sur ses classes) \n// \u00c0 utiliser typiquement apr\u00e8s un passage de niveau ou \u00e0 la cr\u00e9ation.\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n// SCRIPT\n\nfunction getAbbr(name) {\n  if(name == \"Barbare\") { return \"Brb\" }\n  else if(name == \"Pr\u00eatre combattant\") { return \"Prc\" }\n  else if(name == \"Pr\u00eatre combattant\") { return \"Prc\" }\n  else if(name == \"Archer-mage\") { return \"ArM\" }\n  else if(name == \"Champion occultiste\") { return \"Chp\" }\n  else if(name == \"Magus\") { return \"Mgs\" }\n  else if(name == \"Chaman\") { return \"Chm\" }\n  else { return name.substring(0,3) }\n};\n\nconst actors = MacrosPF1.getActors()\n\nif (actors.length != 1) { \n  ui.notifications.error(\"Veuillez choisir un personnage dans la sc\u00e8ne!\")\n} else {\n  let actor = actors[0]\n\n  Dialog.confirm({\n    title: \"Mise \u00e0 jour des aptitudes\",\n    content: `Des aptitudes seront automatiquement ajout\u00e9es \u00e0 <b>${actor.name}</b> en fonction de ses classes.`,\n      yes: function() {\n\n        let classes = []\n        let classfeatures = []\n        for(let i=0; i<actor.data.items.length; i++) {\n          const item = actor.data.items[i]\n          if(item.type == \"feat\" && item.data.featType == \"classFeat\") {\n            classfeatures.push(item.name)\n          } else if(item.type == \"class\") {\n            classes.push(item)\n          }\n        }\n        \n        if(classes.length > 0) {\n          const pack = game.packs.get(\"pf1-fr.classfeaturesfr\");\n          pack.getIndex().then(index => {\n            let features = []\n            classes.forEach(c => {\n              let abbr = getAbbr(c.name)\n              let level = Number(c.data.level)\n              for(let lvl=1; lvl<=level; lvl++) {\n                for(const i in index) { \n                  const f = index[i]\n                  if(f.name.startsWith(`${abbr} ${lvl}:`) && classfeatures.indexOf(f.name) < 0) {\n                    features.push(pack.getEntity(f._id))\n                  }\n                }\n              }\n            });\n            Promise.all(features).then(list => {\n              let toAdd = []\n              list.forEach( f => { if(f.data.data.tags[0].indexOf(\"De base\") >= 0) { toAdd.push(f) } } );\n              actor.createEmbeddedEntity(\"OwnedItem\", toAdd)\n              ui.notifications.info(`${toAdd.length} aptitude(s) ajout\u00e9es!`)\n            });\n          });\n        }\n      },\n      no: () => {}\n  });\n}\n", "img": "systems/pf1/icons/skills/blue_18.jpg", "actorIds": [], "_id": "UN955S6O6dX0xzmM"}
{"name": "Incanter le sort \"Image miroir\"", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet de lancer le sort \"Image miroir\" et d'activer les effets sur le token.\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : Magic Token FX (0.4.2b)\n// Modules(s) optionnel(s) : Macro Marker (voir NOTES)\n// Auteur(s) : Alexandre Nizoux (deurk#5568), Sven Werlen (Dorgendubal#3348), Noon\n\n///// CONFIGURATION\nconst spellName = \"Image miroir\";\nconst messagePrefix = \"Nombre d'images miroir g\u00e9n\u00e9r\u00e9es: \";\n\n///// SCRIPT\nfunction macroCastMirrorImages() {\n    \n    if( !MacrosPF1.hasModule(\"tokenmagic\") ) return ui.notifications.error(\"Cette macro requiert le module <i>Magic Token FX</i>.\");\n  \n    // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n    const actors = MacrosPF1.getActors()\n   \n    // V\u00e9rifier que l'acteur existe\n    if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n    const hero = actors[0];\n\n    // V\u00e9rifier qu'un jeton de l'acteur existe\n    const token = canvas.tokens.placeables.find(token => token.actor.id === hero.id);\n    if (!token) return ui.notifications.error(`L'acteur nomm\u00e9 <i>${hero.name}</i> n'a pas de jeton sur la sc\u00e8ne`);\n\n    // V\u00e9rifier que l'acteur dispose bien du sort\n    const spell = hero.items.find(item => item.type === \"spell\" && item.name === spellName);\n    if (!spell) return ui.notifications.error(`L'acteur <i>${hero.name}</i> ne dispose pas du sort <i>${spellName}</i>`);\n        \n    // WORKAROUND : useSpell ne diff\u00e9rencie pas les ex\u00e9cutions r\u00e9ussies ou rat\u00e9es (BUG),\n    // on se base sur les notifications pour d\u00e9terminer le r\u00e9sultat du lancement de sort\n\n    // Lancer le sort et consommer l'emplacement\n    const notifLength =  ui.notifications.active.length;\n    hero.useSpell(spell, {}, {skipDialog: true}).then(result => {\n\n        if (ui.notifications.active.length != notifLength) return;\n        \n        // Definir le nombre d'images \u00e0 afficher\n        const rollData = spell.getRollData();\n        let imagesRoll = new Roll(\"1d4 + floor(@cl/3)\", rollData).roll();\n        const mirrorImages = Math.min(imagesRoll.total, 8);\n\n        // Afficher un message annoncant le nombre d'images g\u00e9n\u00e9r\u00e9es\n        imagesRoll.toMessage({\n            speaker: ChatMessage.getSpeaker({actor: hero}),\n            flavor: messagePrefix,\n            rollMode: game.settings.get(\"core\", \"rollMode\")\n        });\n\n        // Sauvegarder le nombre d'images pour traitement ult\u00e9rieur\n        hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": mirrorImages});\n\n        // Activer l'effet visuel sur le jeton\n        let params = [{\n            filterType: \"images\",\n            filterId: \"myMirrorImages\",\n            time: 0,\n            nbImage: mirrorImages,\n            alphaImg: 0.6,\n            alphaChr: 1.0,\n            blend: 4,\n            ampX: 0.20,\n            ampY: 0.35,\n            zOrder: 20,\n            animated : {\n                time: { \n                    active: true, \n                    speed: 0.0010, \n                    animType: \"move\" \n                }\n            }\n        }];\n        TokenMagic.addUpdateFilters(token, params); \n    });  \n}\n\nmacroCastMirrorImages();\n\n", "img": "systems/pf1/icons/feats/improved-feint.jpg", "actorIds": [], "_id": "FgnRmbsZ0zuxNbBw", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/improved-feint.jpg", "tooltip": "Sort \"Image miroir\" actif!", "colour": "#edc412", "trigger": "\nconst actors = MacrosPF1.getActors()\nreturn actors.length > 0 && actors[0].getFlag(\"pf1\", \"spells.mirrorImages\");\n"}}}}
{"name": "Retirer une image miroir", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet de retirer une image miroir (\u00e0 utiliser apr\u00e8s la macro d'incantation!)\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : Magic Token FX (0.4.2b)\n// Modules(s) optionnel(s) : -\n// Auteur(s) : Alexandre Nizoux (deurk#5568), Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst heroName = \"Anton Haralamb\";\n\n///// SCRIPT\nfunction removeSingleMirrorImage() {\n    \n    if( !MacrosPF1.hasModule(\"tokenmagic\") ) return ui.notifications.error(\"Cette macro requiert le module <i>Magic Token FX</i>.\");\n  \n    // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n    const actors = MacrosPF1.getActors()\n   \n    // V\u00e9rifier que l'acteur existe\n    if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n    const hero = actors[0];\n  \n    // V\u00e9rifier qu'un jeton de l'acteur existe\n    const token = canvas.tokens.placeables.find(token => token.actor.id === hero.id);\n    if (!token) return ui.notifications.error(`L'acteur nomm\u00e9 <i>${hero.name}</i> n'a pas de jeton sur la sc\u00e8ne`);\n\n    // R\u00e9cup\u00e9rer le nombre d'images miroir et le mettre \u00e0 jour\n    let mirrorImages = hero.getFlag(\"pf1\", \"spells.mirrorImages\") - 1;\n    hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": (mirrorImages < 1 ? 0 : mirrorImages)});\n    \n    // Supprimer l'effet visuel du jeton si il ne reste plus d'images miroir\n    if (mirrorImages < 1) return TokenMagic.deleteFilters(token, \"myMirrorImages\");\n    \n    // Mettre \u00e0 jour le nombre d'images miroir et ajuster l'effet visuel sur le jeton\n    hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": mirrorImages});\n    let params = [{\n        filterType: \"images\",\n        filterId: \"myMirrorImages\",\n        nbImage: mirrorImages,\n    }];\n    TokenMagic.addUpdateFilters(token, params); \n}\n\nremoveSingleMirrorImage();\n\n", "img": "systems/pf1/icons/spells/explosion-orange-1.jpg", "actorIds": [], "_id": "xkoqViB0HUTEIPHC"}
