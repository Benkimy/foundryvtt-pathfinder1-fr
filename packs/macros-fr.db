{"name": "effet", "type": "script", "scope": "global", "command": "// Macro utilitaire qui ne doit pas \u00eatre utilis\u00e9e individuellement\n//\n//\n//\n/*- DOCUMENTATION -*/\n// Adaptation francophone de: https://gitlab.com/JusticeNoon/foundry-macros/-/blob/master/PF1E%20Entity-Link/Utilities/Force%20Update%20All.js\n//\n// Syntaxe: <Action> <Nom effet> [de/sur <cibles>] [etq <Nom alternatif>] [au <niveau>]\n//\n// Action: \n//   Appliquer:  Cr\u00e9e et active un effet\n//   Retirer:    D\u00e9sactive et supprime un effet\n//   Permuter:   D\u00e9sactive un effet si activ\u00e9 ou l'inverse (change l'\u00e9tat). Cr\u00e9e l'effet s'il n'existe pas\n//   Activer:    Active l'effet si pr\u00e9sent\n//   D\u00e9sactiver: D\u00e9sactive l'effet ou le cr\u00e9e\n//   Changer:    Ne fait rien sauf modifier le niveau\n//\n// Nom de l'effet:\n//   Cherche en priorit\u00e9 dans la liste de compendium (compendiumPriority), puis dans \"pf1-fr.buffsfr\" par d\u00e9faut\n//\n// Cibles (S\u00e9par\u00e9es par des virgules, \"-\" pour retirer):\n//   s\u00e9lection: (d\u00e9faut). Les jetons/acteurs s\u00e9lectionn\u00e9s\n//   [nom]:     L'acteur correspondant au nom\n//   cible(s):  Toutes les cibles\n//   template:  Tous les jetons/acteurs sous le dernier template\n//   moi:       La personne sur la carte (chat) ou le personnage du joueur\n//   actif:     L'acteur actif de la personne\n//   #[uuid]:   Utilis\u00e9 \u00e0 l'interne pour l'instant\n//\n// Nom alternatif:\n//   Recherche le nom alternatif ou l'original. Les guillemets ne fonctionnent pas. Utiliser _ si le nom contient un mot-cl\u00e9 (de,sur,etq,au)\n//\n// Niveau\n//   Niveau:    Sp\u00e9cifie le niveau si indiqu\u00e9.\n//   @cl-[1,2,3,s]\tAccepte les donn\u00e9es \"rollData\". @cl-1, @cl-2, @cl-3, @cl-s sont des raccourcis pour @attributes.spells.spellbooks.X.cl.total\n\nconst c = {\n\tcompendiumPriority: [\"world.buffs\"]\n}\n\n/*-\t\t\tCOMMAND\t\t\t\t\t-*/\ntry {\nvar isEvent = typeof event.srcElement.closest === \"function\"\n\tvar inputText =  window.macroChain?.pop() || (isEvent && event.srcElement.closest('button,a')?.textContent.trim()),\n\t\tmacroId = this.id,\n\t\tchatMessage = isEvent ? game.messages.get(event.srcElement.closest('.message')?.getAttribute('data-message-id')) : null,\n\t\targParse = /^([aA]ppliquer|[rR]etirer|[pP]ermuter|[aA]ctiver|[dD\u00e9sactiver]|[cC]hanger) \"?([^\\n]*?)\"?( (?:de|sur|etq|au|pour)(?=([^\"\\\\]*(\\\\.|\"([^\"\\\\]*\\\\.)*[^\"\\\\]*\"))*[^\"]*$) (?:.*))?$/,\n\t\toperator, buffName, modString,\n\t\tcompCollNames = c.compendiumPriority.concat(['pf1-fr.buffsfr']),\n\t\tcompSearches = [],\n\t\tmyself = game.actors.get(chatMessage?.data.speaker?.actor) ?? game.user.character ?? canvas.tokens.controlled[0]?.actor,\n\t\ttargets,\n\t\tmodList,\n\t\ttargetActors = [],\n\t\texcludedActors = [],\n\t\taltName,\n\t\tlevelOverride;\n\tif (inputText.indexOf('::') == 0)\n\t\tinputText = /['`\"](.*)['`\"],.*/.exec(event.srcElement.previousElementSibling?.title.trim())?.[1];\n\t[operator, buffName, modString] = inputText.match(argParse).filter(o => o).slice(1,4);\n\n\tif (modString) {\n\t\tmodList = modString.split(/ (de|sur|etq|au) /).slice(1);\n\t\tfor (var k = 0; k < modList.length; k += 2) {\n\t\t\tswitch(modList[k]) {\n\t\t\t\tcase 'de':\n\t\t\t\tcase 'sur':\n\t\t\t\t\ttargets = modList[k+1].replace(/_/g,' ');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'etq':\n\t\t\t\t\taltName = modList[k+1].replace(/_/g,' ');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'au':\n\t\t\t\t\tif (modList[k+1].indexOf('->') > -1)\n\t\t\t\t\t\tmodList[k+1] = event.srcElement.nextElementSibling?.textContent.trim();\n\t\t\t\t\tlevelOverride = modList[k+1];\n\t\t\t\t\tif (levelOverride.search(/[^\\d]/) > -1) {\n\t\t\t\t\t\tlet shorthand = {\t'cl-1': myself.data.data.attributes.spells.spellbooks.primary.cl.total,\n\t\t\t\t\t\t\t\t\t\t\t'cl-2': myself.data.data.attributes.spells.spellbooks.secondary.cl.total,\n\t\t\t\t\t\t\t\t\t\t\t'cl-3': myself.data.data.attributes.spells.spellbooks.tertiary.cl.total,\n\t\t\t\t\t\t\t\t\t\t\t'cl-s': myself.data.data.attributes.spells.spellbooks.spelllike.cl.total};\n\t\t\t\t\t\tlevelOverride = (new Roll(levelOverride, Object.assign(shorthand, myself.data.data)).roll()).total;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!targets) targets = 's\u00e9lection';\n\t(targets ? targets.split(',') : ['s\u00e9lection']).forEach(tar => {\n\t\tvar accuActors;\n\t\ttar = tar.trim();\n\t\tif (tar.charAt(0) == '-') {\n\t\t\taccuActors = excludedActors;\n\t\t\ttar = tar.slice(1);\n\t\t}\n\t\telse\n\t\t\taccuActors = targetActors;\n\t\tswitch(tar.toLowerCase()) {\n\t\t\tcase 's\u00e9lection':\n\t\t\t\tif (canvas.tokens.controlled.length == 0) ui.notifications.warn('Aucun jeton s\u00e9lectionn\u00e9');\n\t\t\t\taccuActors.push(...canvas.tokens.controlled.map(o => o.actor));\n\t\t\t\tbreak;\n\t\t\tcase 'template':\n\t\t\t\tlet temp = chatMessage?.data.flags.pf1?.metadata?.template ?? canvas.templates.objects.children.filter(o => o.data.user == game.userId)?.pop()?.id;\n\t\t\t\tif (!temp) ui.notifications.warn('Aucun template trouv\u00e9');\n\t\t\t\telse {\n\t\t\t\t\tlet tokens = canvas.tokens.objects.children.filter(o => canvas.grid.getHighlightLayer('Template.' + temp).geometry.containsPoint(o.center));\n\t\t\t\t\taccuActors.push(...tokens.map(o => o.actor));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'cible':\n\t\t\tcase 'cibles':\n\t\t\t\taccuActors.push(...[...game.user.targets].map(o => o.actor));\n\t\t\t\tbreak;\n\t\t\tcase 'moi':\n\t\t\t\taccuActors.push(myself);\n\t\t\t\tbreak;\n\t\t\tcase 'actif':\n\t\t\t\taccuActors.push(game.pf1.ActorPF.getActiveActor());\n\t\t\t\tbreak;\n\t\t\tcase 'restant':\n\t\t\t\ttar = '#' + chatMessage?.data.flags.applyBuff?.remaining;\n\t\t\t\tif (tar == '#undefined')\n\t\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//Name or uuid search\n\t\t\t\tif (tar.indexOf('#') != 0)\n\t\t\t\t\taccuActors.push(game.actors.find(o => o.name == tar));\n\t\t\t\telse {\n\t\t\t\t\tvar [uScene, uToken, uActor] = tar.match(/^#(?:Scene\\.([^.]*))?(?:\\.Token\\.([^.]*))?(?:\\.?Actor\\.([^.]*))?$/).slice(1);\n\t\t\t\t\tif (uActor)\n\t\t\t\t\t\taccuActors.push(game.actors.get(uActor));\n\t\t\t\t\telse if (uScene == canvas.id)\n\t\t\t\t\t\taccuActors.push(canvas.tokens.objects.children.find(o => o.id == uToken).actor);\n\t\t\t\t}\n\t\t}\n\t});\n\n\texcludedActors = excludedActors.map(o => o.id);\n\ttargetActors = [...new Set(targetActors)].filter(o => o && !excludedActors.includes(o.id));\n\texcludedActors = [];\n\t\n\t//This is only moved down here so I can assume all the serialized stuff above is done\n\tcompCollNames.forEach((coll, place) => {\n\t\tcompSearches[place] = new Promise((resolve, reject) => {\n\t\t\t(async () => {\n\t\t\t\tlet pack = game.packs.get(coll);\n\t\t\t\tif (pack) {\n\t\t\t\t\tlet search = await pack.getIndex().then(p => p.find(o => o.name == buffName));\n\t\t\t\t\tif (search)\n\t\t\t\t\t\tpack.getEntity(search._id).then(bItem => resolve(bItem));\n\t\t\t\t\telse\n\t\t\t\t\t\t resolve(false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresolve(false);\n\t\t\t})();\t\t\t\n\t\t});\n\t});\n\tPromise.all(compSearches).then(comps => buffFound(comps.find(c => c)));\n}\ncatch (err) {\n\tconsole.log(err, \"Votre commande n'a pas fonctionn\u00e9\");\n}\nfunction buffFound(buff) {\n\tif (typeof levelOverride != 'undefined') buff.data.data.level = levelOverride;\n\tif (typeof altName != 'undefined') buff.data.name = altName;\n\ttargetActors.forEach(act => {\n\t\tif (act && act.hasPerm(game.user, 'OWNER')) {\n\t\t\tlet presentBuff = act.items.find(o => {return o.data.type == 'buff' && (o.name == buffName || o.name == altName);});\n\t\t\tlet updateArgs = [];\n\t\t\tswitch(operator.toLowerCase()) {\n\t\t\t\tcase 'appliquer':\n\t\t\t\t\tif (!buff.data.data.active)\n\t\t\t\t\t\tbuff.data.data.active = true;\n\t\t\t\t\t\n\t\t\t\t\tif (presentBuff)\n\t\t\t\t\t\tpresentBuff.update({'data.active': true, 'data.level': buff.data.data.level, 'name': buff.data.name});\n\t\t\t\t\telse\n\t\t\t\t\t\tact.createOwnedItem(buff);\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'retirer':\n\t\t\t\t\tif (presentBuff)\n\t\t\t\t\t\tpresentBuff.delete();\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'permuter':\n\t\t\t\t\tif (presentBuff)\n\t\t\t\t\t\tpresentBuff.update({'data.active': !getProperty(presentBuff.data, 'data.active'), 'data.level': buff.data.data.level, 'name': buff.data.name});\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!buff.data.data.active)\n\t\t\t\t\t\t\tbuff.data.data.active = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tact.createOwnedItem(buff);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'activer':\n\t\t\t\t\tif (presentBuff)\n\t\t\t\t\t\tpresentBuff.update({'data.active': true, 'data.level': buff.data.data.level, 'name': buff.data.name});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd\u00e9sactiver':\n\t\t\t\t\tif (presentBuff)\n\t\t\t\t\t\tpresentBuff.update({'data.active': false, 'data.level': buff.data.data.level, 'name': buff.data.name});\n\t\t\t\t\telse\n\t\t\t\t\t\tact.createOwnedItem(buff);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'changer':\n\t\t\t\t\tif (presentBuff && typeof levelOverride != 'undefined')\n\t\t\t\t\t\tpresentBuff.update({'data.level': buff.data.data.level, 'name': buff.data.name});\n\t\t\t\tdefault:\n\t\t\t\t\tui.notifications.warn(\"Commande inconnue. Se r\u00e9f\u00e9rer \u00e0 la documentation!\");\n\t\t\t}\n\t\t}\n\t\telse if (act)\n\t\t\texcludedActors.push(act);\n\t});\n\tvar successStr = 'Aucun jeton/acteur affect\u00e9.',\n\t\taffectedActors = targetActors.length - excludedActors.length;\n\tif (affectedActors != 0)\n\t\tsuccessStr = `${buff.data.name} chang\u00e9 sur ${affectedActors} jeton/acteur${(affectedActors > 1 ? 's' : '')}.`;\n\tif (excludedActors.length > 0) {\n\t\tsuccessStr += ' Requiert l\\'assistance du MJ pour le reste.';\n\t\tvar remainingModList = modList.filter((o,p) => o != 'to' && modList[p-1] != 'to'),\n\t\t\texcludedNames = excludedActors.map(o => (o.token ? o.token.name : o.name)).join(', '),\n\t\t\tgmButtonTitle = `${operator} ${buffName} sur restant ${remainingModList.join(' ')}`.trim(),\n\t\t\tenrichedButton = `<a class=\"entity-link\" data-entity=\"Macro\" data-id=\"${macroId}\"><i class=\"fas fa-terminal\"></i> ${gmButtonTitle}</a>`,\n\t\t\tflavorText = `J'essaie de<br>${enrichedButton}<br>Le reste: ${excludedNames}`,\n\t\t\tremainingUUID = excludedActors.map(o => (o.token ? o.token.uuid : o.uuid)).join(','),\n\t\t\tspoofedRoll = new Roll(excludedActors.length.toString()).roll();\n\t\tspoofedRoll.formula = 'Affectera:';\n\t\t\tChatMessage.create({\n\t\t\tblind: true,\n\t\t\tsound: null,\n\t\t\tflavor: flavorText,\n\t\t\tspeaker: ChatMessage.getSpeaker(),\n\t\t\tcontent: 'Je vais \u00eatre supprim\u00e9',\n\t\t\ttype: CONST.CHAT_MESSAGE_TYPES.ROLL,\n\t\t\troll: spoofedRoll,\n\t\t\twhisper: ChatMessage.getWhisperRecipients(\"GM\"),\n\t\t\tflags: {applyBuff: {remaining: remainingUUID}}\n\t\t});\n\t}\n\tui.notifications.info(successStr.trim());\n}\n\n", "img": "systems/pf1/icons/spells/air-burst-sky-1.jpg", "actorIds": [], "_id": "yAC3DxS0LGLuwzlB"}
{"name": "\u00c9mettre de la lumi\u00e8re", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer/d\u00e9sactiver de la lumi\u00e8re sur un token\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst porteeCourte = 3;\nconst porteeLongue = 2 * porteeCourte;\n\n///// SCRIPT\nconst tokens = canvas.tokens.controlled.filter( t => t.actor && t.actor.hasPerm(game.user, \"OWNER\") )\n\nif( tokens.length == 0 ) { ui.notifications.error(\"Veuillez choisir un token sur la sc\u00e8ne!\"); }\nelse {\n  tokens.forEach( t => {\n    const radius1 = t.brightLightRadius > 0 || t.dimLightRadius > 0 ? 0 : porteeCourte\n    const radius2 = t.brightLightRadius > 0 || t.dimLightRadius > 0 ? 0 : porteeLongue\n    const hasLight = t.brightLightRadius > 0 || t.dimLightRadius > 0\n    t.update({brightLight: radius1, dimLight: radius2});\n    MacroMarker.toggle(this);\n  })\n}\n\n", "img": "systems/pf1/icons/items/inventory/lantern.jpg", "actorIds": [], "_id": "9ePEn6JQj3f7cB3T", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/items/inventory/lantern.jpg", "tooltip": "Retirer la lumi\u00e8re", "colour": "#edc412", "trigger": "\nconst tokens = canvas.tokens.controlled.filter( t => t.actor && t.actor.hasPerm(game.user, \"OWNER\") )\nreturn tokens.length > 0 && (tokens[0].brightLightRadius > 0 || tokens[0].dimLightRadius > 0)\n"}}}}
{"name": "Combattre sur la d\u00e9fensive", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer ou de d\u00e9sactiver l'attaque sur la d\u00e9fensive (s\u00e9lection)\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst COMMAND = 'Permuter \"Combattre sur la d\u00e9fensive\"'\n\n//// SCRIPT\nMacrosPF1.applyBuff(COMMAND)\n\n", "img": "systems/pf1/icons/feats/improved-shield-bash.jpg", "actorIds": [], "_id": "1IqmhS75L8bVcNqp", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/improved-shield-bash.jpg", "tooltip": "Combattre normalement", "colour": "#bba8a8", "trigger": "\nconst actors = MacrosPF1.getActors()\nif( actors.length > 0 ) {\n  const hero = actors[0];\n  const buff = hero.items.find( i => i.type === \"buff\" && i.name === \"Combattre sur la d\u00e9fensive\" )\n  return buff && getProperty(buff.data, \"data.active\")\n} \nreturn false\n"}}}}
{"name": "Activer D\u00e9fense Totale", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet d'activer ou de d\u00e9sactiver la d\u00e9fense totale sur un personnage\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst COMMAND = 'Permuter \"D\u00e9fense totale\"'\n\n//// SCRIPT\nMacrosPF1.applyBuff(COMMAND)\n", "img": "systems/pf1/icons/feats/shield-slam.jpg", "actorIds": [], "_id": "Tta2l2WwXVnBObxA", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/shield-slam.jpg", "tooltip": "D\u00e9sactiver D\u00e9fense Totale", "colour": "#bba8a8", "trigger": "\nconst actors = MacrosPF1.getActors()\nif( actors.length > 0 ) {\n  const hero = actors[0];\n  const buff = hero.items.find( i => i.type === \"buff\" && i.name === \"D\u00e9fense totale\" )\n  return buff && getProperty(buff.data, \"data.active\")\n} \nreturn false\n"}}}}
{"name": "Mettre \u00e0 jour les aptitudes", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro ajoute les aptitudes sur un PJ (bas\u00e9 sur ses classes) \n// \u00c0 utiliser typiquement apr\u00e8s un passage de niveau ou \u00e0 la cr\u00e9ation.\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n// SCRIPT\n\nfunction getAbbr(name) {\n  if(name == \"Barbare\") { return \"Brb\" }\n  else if(name == \"Pr\u00eatre combattant\") { return \"Prc\" }\n  else if(name == \"Archer-mage\") { return \"ArM\" }\n  else if(name == \"Champion occultiste\") { return \"Chp\" }\n  else if(name == \"Magus\") { return \"Mgs\" }\n  else if(name == \"Chaman\") { return \"Chm\" }\n  else { return name.substring(0,3) }\n};\n\nconst actors = MacrosPF1.getActors()\n\nif (actors.length != 1) { \n  ui.notifications.error(\"Veuillez choisir un personnage dans la sc\u00e8ne!\")\n} else {\n  let actor = actors[0]\n\n  Dialog.confirm({\n    title: \"Mise \u00e0 jour des aptitudes\",\n    content: `Des aptitudes seront automatiquement ajout\u00e9es \u00e0 <b>${actor.name}</b> en fonction de ses classes.`,\n      yes: function() {\n\n        let classes = []\n        let classfeatures = []\n        for(let i=0; i<actor.data.items.length; i++) {\n          const item = actor.data.items[i]\n          if(item.type == \"feat\" && item.data.featType == \"classFeat\") {\n            classfeatures.push(item.name)\n          } else if(item.type == \"class\") {\n            classes.push(item)\n          }\n        }\n        \n        if(classes.length > 0) {\n          const pack = game.packs.get(\"pf1-fr.classfeaturesfr\");\n          pack.getIndex().then(index => {\n            let features = []\n            classes.forEach(c => {\n              let abbr = getAbbr(c.name)\n              let level = Number(c.data.level)\n              for(let lvl=1; lvl<=level; lvl++) {\n                for(const i in index) { \n                  const f = index[i]\n                  if(f.name.startsWith(`${abbr} ${lvl<10?\" \":\"\"}${lvl} :`) && classfeatures.indexOf(f.name) < 0) {\n                    features.push(pack.getEntity(f._id))\n                  }\n                }\n              }\n            });\n            Promise.all(features).then(list => {\n              let toAdd = []\n              list.forEach( f => { if(f.data.data.tags[0].indexOf(\"De base\") >= 0) { toAdd.push(f) } } );\n              actor.createEmbeddedEntity(\"OwnedItem\", toAdd)\n              ui.notifications.info(`${toAdd.length} aptitude(s) ajout\u00e9es!`)\n            });\n          });\n        }\n      },\n      no: () => {}\n  });\n}\n", "img": "systems/pf1/icons/skills/blue_18.jpg", "actorIds": [], "_id": "UN955S6O6dX0xzmM"}
{"name": "Canalisation d'\u00e9nergie", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro lance une canalisation d'\u00e9nergie en permettant de choisir s'il s'agit\n// d'un soin ou de d\u00e9g\u00e2ts. Techniquement, la macro va changer le type d'attaque sur\n// l'aptitude en question avant de l'ex\u00e9cuter.\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : -\n// Auteur(s) : Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst FEATNAME = \"Pr\u00ea  1 : Canalisation d'\u00e9nergie 1d6\"\n\n///// SCRIPT\nfunction macroChannelEnergy() {\n\n  // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n  const actors = MacrosPF1.getActors()\n    \n  // V\u00e9rifier que l'acteur existe\n  if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n  const hero = actors[0];\n\n  let feat = hero.items.find( i => i.type === \"feat\" && i.name === FEATNAME )\n  if( !feat ) {\n    ui.notifications.error(`Le PJ <i>${hero.name}</i> ne poss\u00e8de pas l'aptitude <i>${FEATNAME}</i>. Veuillez l'ajouter!`);\n  } else {\n    new Dialog({\n        title: \"Soigner ou blesser\",\n        content: `Cette macro ex\u00e9cutera l'aptitude <i>${FEATNAME}</i> avec le PJ <i>${hero.name}</i>, apr\u00e8s avoir modifi\u00e9 le type d'attaque (soin/autre). Choisissez le type de canalisation d'\u00e9nergie.`,\n        buttons: {\n          one: {\n            icon: '<i class=\"fas fa-heart\"></i>',\n            label: \"Soigner\",\n            callback: () => { feat.data.data.actionType = \"heal\"; feat.use({ev: null}) } \n          },\n          two: {\n            icon: '<i class=\"fas fa-skull\"></i>',\n            label: \"Blesser\",\n            callback: () => { feat.data.data.actionType = \"other\"; feat.use({ev: null}) } \n          }\n        },\n        default: \"one\",\n      }).render(true);\n  }\n}\n\nmacroChannelEnergy();\n", "img": "systems/pf1/icons/feats/extra-mercy.jpg", "actorIds": [], "_id": "lhSoNvhUMvfYYVh2"}
{"name": "Incanter le sort \"Image miroir\"", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet de lancer le sort \"Image miroir\" et d'activer les effets sur le token.\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : Magic Token FX (0.4.2b)\n// Modules(s) optionnel(s) : Macro Marker (voir NOTES)\n// Auteur(s) : Alexandre Nizoux (deurk#5568), Sven Werlen (Dorgendubal#3348), Noon\n\n///// CONFIGURATION\nconst spellName = \"Image miroir\";\nconst messagePrefix = \"Nombre d'images miroir g\u00e9n\u00e9r\u00e9es: \";\n\n///// SCRIPT\nfunction macroCastMirrorImages() {\n    \n    if( !MacrosPF1.hasModule(\"tokenmagic\") ) return ui.notifications.error(\"Cette macro requiert le module <i>Magic Token FX</i>.\");\n  \n    // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n    const actors = MacrosPF1.getActors()\n   \n    // V\u00e9rifier que l'acteur existe\n    if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n    const hero = actors[0];\n\n    // V\u00e9rifier qu'un jeton de l'acteur existe\n    const token = canvas.tokens.placeables.find(token => token.actor.id === hero.id);\n    if (!token) return ui.notifications.error(`L'acteur nomm\u00e9 <i>${hero.name}</i> n'a pas de jeton sur la sc\u00e8ne`);\n\n    // V\u00e9rifier que l'acteur dispose bien du sort\n    const spell = hero.items.find(item => item.type === \"spell\" && item.name === spellName);\n    if (!spell) return ui.notifications.error(`L'acteur <i>${hero.name}</i> ne dispose pas du sort <i>${spellName}</i>`);\n        \n    // WORKAROUND : useSpell ne diff\u00e9rencie pas les ex\u00e9cutions r\u00e9ussies ou rat\u00e9es (BUG),\n    // on se base sur les notifications pour d\u00e9terminer le r\u00e9sultat du lancement de sort\n\n    // Lancer le sort et consommer l'emplacement\n    const notifLength =  ui.notifications.active.length;\n    hero.useSpell(spell, {}, {skipDialog: true}).then(result => {\n\n        if (ui.notifications.active.length != notifLength) return;\n        \n        // Definir le nombre d'images \u00e0 afficher\n        const rollData = spell.getRollData();\n        let imagesRoll = new Roll(\"1d4 + floor(@cl/3)\", rollData).roll();\n        const mirrorImages = Math.min(imagesRoll.total, 8);\n\n        // Afficher un message annoncant le nombre d'images g\u00e9n\u00e9r\u00e9es\n        imagesRoll.toMessage({\n            speaker: ChatMessage.getSpeaker({actor: hero}),\n            flavor: messagePrefix,\n            rollMode: game.settings.get(\"core\", \"rollMode\")\n        });\n\n        // Sauvegarder le nombre d'images pour traitement ult\u00e9rieur\n        hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": mirrorImages});\n\n        // Activer l'effet visuel sur le jeton\n        let params = [{\n            filterType: \"images\",\n            filterId: \"myMirrorImages\",\n            time: 0,\n            nbImage: mirrorImages,\n            alphaImg: 0.6,\n            alphaChr: 1.0,\n            blend: 4,\n            ampX: 0.20,\n            ampY: 0.35,\n            zOrder: 20,\n            animated : {\n                time: { \n                    active: true, \n                    speed: 0.0010, \n                    animType: \"move\" \n                }\n            }\n        }];\n        TokenMagic.addUpdateFilters(token, params); \n    });  \n}\n\nmacroCastMirrorImages();\n\n", "img": "systems/pf1/icons/feats/improved-feint.jpg", "actorIds": [], "_id": "FgnRmbsZ0zuxNbBw", "flags": {"macro-marker": {"activeData": {"icon": "systems/pf1/icons/feats/improved-feint.jpg", "tooltip": "Sort \"Image miroir\" actif!", "colour": "#edc412", "trigger": "\nconst actors = MacrosPF1.getActors()\nreturn actors.length > 0 && actors[0].getFlag(\"pf1\", \"spells.mirrorImages\");\n"}}}}
{"name": "Retirer une image miroir", "type": "script", "scope": "global", "command": "///// INFORMATIONS\n//\n// Cette macro permet de retirer une image miroir (\u00e0 utiliser apr\u00e8s la macro d'incantation!)\n//\n// Base : Foundry VTT (0.6.6)\n// Syst\u00e8me : Pathfinder 1 (0.73.7)\n// Module(s) n\u00e9cessaire(s) : Magic Token FX (0.4.2b)\n// Modules(s) optionnel(s) : -\n// Auteur(s) : Alexandre Nizoux (deurk#5568), Sven Werlen (Dorgendubal#3348)\n\n///// CONFIGURATION\nconst heroName = \"Anton Haralamb\";\n\n///// SCRIPT\nfunction removeSingleMirrorImage() {\n    \n    if( !MacrosPF1.hasModule(\"tokenmagic\") ) return ui.notifications.error(\"Cette macro requiert le module <i>Magic Token FX</i>.\");\n  \n    // R\u00e9cup\u00e9rer l'acteur s\u00e9lectionn\u00e9\n    const actors = MacrosPF1.getActors()\n   \n    // V\u00e9rifier que l'acteur existe\n    if (!actors.length) return ui.notifications.error(\"Vous ne poss\u00e9dez aucun acteur! Veuillez contacter votre MJ.\");\n    const hero = actors[0];\n  \n    // V\u00e9rifier qu'un jeton de l'acteur existe\n    const token = canvas.tokens.placeables.find(token => token.actor.id === hero.id);\n    if (!token) return ui.notifications.error(`L'acteur nomm\u00e9 <i>${hero.name}</i> n'a pas de jeton sur la sc\u00e8ne`);\n\n    // R\u00e9cup\u00e9rer le nombre d'images miroir et le mettre \u00e0 jour\n    let mirrorImages = hero.getFlag(\"pf1\", \"spells.mirrorImages\") - 1;\n    hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": (mirrorImages < 1 ? 0 : mirrorImages)});\n    \n    // Supprimer l'effet visuel du jeton si il ne reste plus d'images miroir\n    if (mirrorImages < 1) return TokenMagic.deleteFilters(token, \"myMirrorImages\");\n    \n    // Mettre \u00e0 jour le nombre d'images miroir et ajuster l'effet visuel sur le jeton\n    hero.setFlag(\"pf1\", \"spells\", {\"mirrorImages\": mirrorImages});\n    let params = [{\n        filterType: \"images\",\n        filterId: \"myMirrorImages\",\n        nbImage: mirrorImages,\n    }];\n    TokenMagic.addUpdateFilters(token, params); \n}\n\nremoveSingleMirrorImage();\n\n", "img": "systems/pf1/icons/spells/explosion-orange-1.jpg", "actorIds": [], "_id": "xkoqViB0HUTEIPHC"}
